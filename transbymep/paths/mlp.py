import torch
from torch import nn

from .base_path import BasePath
from .linear import LinearPath

class MLPpath(BasePath):
    """
    Multilayer Perceptron (MLP) path class for generating geometric paths.

    Args:
        n_embed (int, optional): Number of embedding dimensions. Defaults to 32.
        depth (int, optional): Depth of the MLP. Defaults to 3.
        base: Path class to correct. Defaults to LinearPath.
    """
    def __init__(
        self,
        n_embed: int = 32,
        depth: int = 3,
        base: BasePath = None,
        **kwargs,
    ):
        super().__init__(**kwargs)

        self.activation = nn.SELU()
        input_sizes = [1] + [n_embed]*(depth - 1)
        output_sizes = input_sizes[1:] + [self.final_point.shape[-1]]
        self.layers = [
            nn.Linear(
                input_sizes[i//2], output_sizes[i//2], dtype=torch.float64
            ) if i%2 == 0 else self.activation\
            for i in range(depth*2 - 1)
        ]
        self.mlp = nn.Sequential(*self.layers)
        self.mlp.to(self.device)
        self.neval = 0

        self.base = base if base is not None else LinearPath(**kwargs)

    def get_geometry(self, time: float, *args):
        """
        Generates a geometric path using the MLP.

        Args:
            time (float): Time parameter for generating the path.
            *args: Additional arguments.

        Returns:
            torch.Tensor: The geometric path generated by the MLP.
        """
        # n_data = len(time)
        mlp_out = self.mlp(time) - (1 - time) * self.mlp(self.t_init) - time * self.mlp(self.t_final)
        # mlp_out = (mlp_out.view(n_data, self.n_atoms, 3) * (self.tags != 0)[None, :, None]).view(n_data,  self.n_atoms * 3)
        # mlp_out = mlp_out.view(n_data, self.n_atoms, 3)
        # mlp_out = mlp_out * (self.tags != 0)[None, :, None]
        # mlp_out = mlp_out.view(n_data, self.n_atoms * 3)
        out = self.base.get_geometry(time) + mlp_out
        return out
