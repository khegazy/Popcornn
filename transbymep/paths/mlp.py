import torch
from torch import nn

from .base_path import BasePath
from typing import Tuple, Optional
import numpy as np


class MLPpath(BasePath):
    """
    Multilayer Perceptron (MLP) path class for generating geometric paths.

    Args:
        potential (callable): The potential energy function.
        initial_point (torch.Tensor): The initial point of the path.
        final_point (torch.Tensor): The final point of the path.
        n_embed (int, optional): Number of embedding dimensions. Defaults to 32.
        depth (int, optional): Depth of the MLP. Defaults to 3.
        seed (int, optional): Random seed. Defaults to 123.
    """
    def __init__(
        self,
        potential: callable,
        initial_point: torch.tensor,
        final_point: torch.tensor,
        n_embed: int = 32,
        depth: int = 3,
        device: torch.device = None,
        seed: int = 123,
    ):
        super().__init__(
            potential=potential,
            initial_point=initial_point,
            final_point=final_point,
            device=device,
        )
        self.activation = nn.SELU()
        input_sizes = [1] + [n_embed]*(depth - 1)
        output_sizes = input_sizes[1:] + [self.final_point.shape[-1]]
        self.layers = [
            nn.Linear(input_sizes[i//2], output_sizes[i//2]) if i%2 == 0\
            else self.activation\
            for i in range(depth*2 - 1)
        ]
        self.mlp = nn.Sequential(*self.layers)
        self.mlp.to(self.device)
        self.neval = 0

    def geometric_path(self, time: float, *args):
        """
        Generates a geometric path using the MLP.

        Args:
            time (float): Time parameter for generating the path.
            *args: Additional arguments.

        Returns:
            torch.Tensor: The geometric path generated by the MLP.
        """
        self.neval += time.numel()
        # print(time)
        if self.neval > 1e4:
            raise ValueError("Too many evaluations!")
        output = self.mlp(time)\
            - (1 - time)*(self.mlp(torch.tensor([[0.]], device=self.device)) - self.initial_point)\
            - time*(self.mlp(torch.tensor([[1.]], device=self.device)) - self.final_point)
        return output

    """
    def get_path(self, times=None):
        if times is None:
            times = torch.unsqueeze(torch.linspace(0, 1., 1000), -1)
        elif len(times.shape) == 1:
            times = torch.unsqueeze(times, -1)

        geo_path = self.geometric_path(times)
        pes_path = self.potential(geo_path)
        
        return geo_path, pes_path
    """